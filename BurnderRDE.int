/*******************************************************************************
Copyright 2003. The U.S. Government, as Represented by the Administrator of
the National Aeronautics and Space Administration (NASA). All rights reserved.
Includes content licensed from the U.S. Government, National Aeronautics and
Space Administration under United States Copyright Registration Numbers
V3503D364 and V3482D344.
Copyright 2008-2015 NPSS Consortium, www.NPSSConsortium.org/AllRightsReserved
*******************************************************************************/

/*******************************************************************************
NPSS software and related documentation is export controlled with an Export
Control Classification Number(ECCN) of 9D991, controlled for Anti-Terrorism
reasons, under U.S. Export Administration Regulations 15 CFR 730-774. It may
not be transferred to a country checked under anti-terrorism on the Commerce
Country Chart structure or to foreign nationals of those countries in the U.S.
or abroad without first obtaining a license from the Bureau of Industry and
Security, United States Department of Commerce. Violations are punishable by
fine, imprisonment, or both.
*******************************************************************************/
//
// For further information contact support@npssconsortium.org
//

#ifndef __BURNER__
#define __BURNER__

#include <InterpIncludes.ncp>


class Burner extends Element {

//------------------------------------------------------------
//     ******* DOCUMENTATION *******
//------------------------------------------------------------

 title = "";

  description = isA() + " will calculate performance for a standard burner.";

  usageNotes = "

- The Burner element performs high level Burner performance
calculations.  This element works with an entrance fluid and
fuel stream.  It mixes the two flows together and then 
performs the burn calculations.  Please note that the Burner
has no control over the actual fuel stream conditions--fuel type,
LHV, etc.  These values are properties of the fuel flow itself
and are usually set in the FuelStart element.   

- There are four ways to specify the Burner exit conditions.  The
first way is specify the Burner fuel-to-air ratio.  The second way 
is to set the fuel flow directly in the Burner (and ignore the fuel 
flow rate coming in through the fuel input port).  The third way is 
to set the Burner exit temperature.  The fourth way is to set the Burner 
fuel flow using the fuel flow coming in through the fuel input port. 
The type of input used is controlled by the Option variable switchBurn.

- Note that if switchBurn is set to FAR, FUEL, or TEMPERATURE, fuel flow rate in
the element upstream of the Burner (usually a FuelStart element) will NOT be
the same value as the Burner Wfuel.  The Burner does set Fu_I.Wfuel, but that
is as far upstream as the fuel flow setting goes.  If the user wishes to relay
the Burner Wfuel to an upstream element, then the user must set up a 
solver balance in order to accomplish this.

- When switchBurn is set to FAR (default), the user must input a value
for Burner FAR (fuel-to-air ratio).  The Burner will set Wfuel based on 
FAR and the inlet air flow rate.  

- When switchBurn is set to FUEL, the user must input a value for the Burner
Wfuel.  The Burner will ignore the fuel flow rate coming in through the 
fuel input port.

- When switchBurn is set to TEMPERATURE, the user must input a value
for Burner TtCombOut.  The Burner will solve for Wfuel based on TtCombOut, 
the fuel inlet conditions, and the air inlet conditions.

- When switchBurn is set to WFUEL, the Burner will use fuel flow rate coming in 
through the fuel input port to set Wfuel.  Burner outputs such as FAR and 
TtCombOut will still be calculated in the Burner using the fuel inlet
conditions and the air inlet conditions.

- The burner tracks several different pressure losses.  The first,
dPqP, accounts for duct friction pressure drops.  The
second, dPqPRayleigh, accounts for the Rayleigh pressure drop.  
dPRayleigh is input or calculated - see switchHotLoss, an iteration 
is necessary since the pressure loss itself is a function of the 
exit conditions. 

- The user can request a pre burner pressure loss dPqP.  The 
pressure loss calculations are performed before all the other
calculations are done.  This means that the combustion entrance 
pressure will not match the value indicated by the burner entrance.

- Burner efficiency (eff) is calculated as follows: effBase * s_eff + a_eff.
If the S_eff socket is filled, then effBase will be set by the socket.  
Otherwise, the user may input a value between 0 and 1 for effBase.
Efficiency is used in the Fl_Ocomb FlowStation as follows:
Fl_Ocomb.burn( Fu_I, eff ).  Therefore, efficiency only applies to 
thermo packages whose burn function supports efficiency as an input.
(NOTE: the CEA burn function ignores eff.  See the NPSS Thermodynamic Property
Package User Guide for more information on burn efficiency in CEA)

- Heat transfer rate (Qhx) between the fluid and burner structural material may 
be specified by the user.  If the S_Qhx socket is filled, then Qhx will be set
by the socket.  Qhx is commonly used to model thermal transients during
transient operation.  Qhx is applied to the fluid exit conditions (affecting
exit enthalpy and temperature) after all other burner calculations are
performed.
";

background = "";

  //------------------------------------------------------------
  //     ******* SETUP VARIABLES ********
  //------------------------------------------------------------

  real a_dPqPf {
    value = 0.0;  IOstatus = "input";  units = "none";
    description = "Duct friction pressure drop adder";
  }
  real a_dPqPfAud {
    value = 0.0;  IOstatus = "unset";  units = "psia";
    description = "Audit factor adder applied to pressure ratio";
  }
  real a_eff {
    value = 0.0;  IOstatus = "input";  units = "none";
    description = "Adiabatic efficiency adder";
  }
  real dPqPf {
    value = 0.0;  IOstatus = "output";  units = "none";
    description = "Adjusted duct friction pressure drop";
  }
  real dPqP {
    value = 0.0;  IOstatus = "output";  units = "none";
    description = "Overall pressure drop";
  }
  real dPqP_dmd {
    value = 0.0;  IOstatus = "input";  units = "none";
    description = "Duct friction pressure drop ";
  }
  real dPqPRayleigh {
    value = 0.0;  IOstatus = "input";  units = "none"; 
    description = "Adjusted Rayleigh pressure drop";
  }
  real eff {
    value = 1.0;  IOstatus = "output";  units = "none";
    description = "Adjusted adiabatic burner efficiency";
  }
  real effBase {
    value = 1.0;  IOstatus = "input";  units = "none";
    description = "Adiabatic burner efficiency, from socket ";
  }
  real FAR {
    value = 0.0;  IOstatus = "output";  units = "none";
    description = "Fuel-to-air ratio";
  }
  real FARDes {
    value = 0.0;  IOstatus = "output";  units = "none";
    description = "Fuel-to-air ratio at design";
  }
  real fuelFractV {
    value = 0.0;  IOstatus = "input";	units = "none";
    description = "Fraction of the incoming flow velocity fuel enters the burner";
  }
  real Qhx {
    value = 0.0;  IOstatus = "input";  units = "Btu/sec";
    description = "Heat loss to thermal mass storage";
  }
  real PqPRayleigh {
    value = 1.0;  IOstatus = "output";  units = "none";
    description = "Adjusted Rayleigh pressure drop";
  }
  real PqPRayleighDelta {
    value = 0.0;  IOstatus = "output";  units = "none";
    description = "Bounded Rayleigh pressure drop - for loop only";
  }
  real PqPRayleighError {
    value = 1.0;  IOstatus = "output";  units = "none";
    description = "Adjusted Rayleigh pressure drop error";
  }
  real PqPRayleighMin {
    value = 0.05;  IOstatus = "input";  units = "none";
    description = "Rayleigh pressure drop lower limit - for loop only";
  }
  real PqPRayleighStep {
    value = 0.05;  IOstatus = "input";  units = "none";
    description = "Maximum step for Rayleigh pressure drop - for loop only";
  }
  real PqPRayleighNew {
    value = 1.0;  IOstatus = "output";  units = "none";
    description = "Previous adjusted Rayleigh pressure drop - for loop only";
  }
  real s_dPqPf {
    value = 1.0;  IOstatus = "input";  units = "none";
    description = "Duct friction pressure drop scalar";
  }
  real s_dPqPfAud {
    value = 1.0;  IOstatus = "unset";  units = "none";
    description = "Audit factor scalar applied to pressure ratio";
  }
  real s_eff {
    value = 1.0;  IOstatus = "input";  units = "none";
    description = "Adiabatic efficiency scalar";
  }
  real tolRayleigh {
    value = 4e-05;  IOstatus = "input";  units = "none";
    description = "Iteration tolerance on momentum pressure drop";
  }
  real tolWfuel {
    value = 1e-05;  IOstatus = "input";  units = "none";
    description = "Iteration tolerance on temperature burn";
  }
  real TtCombOut {
    value = 0.0;  IOstatus = "input";  units = "R";
    description = "Exit temperature";
  }
  real TtLast {
    value = 0.0;  IOstatus = "input";  units = "R";
    description = "Previous exit temperature - for loop only";
  }
  real Wfuel {
    value = 0.0;  IOstatus = "input";  units = "lbm/sec";
    description = "Combustor fuel flow";
  }
  real WfuelError {
    value = 0.0;  IOstatus = "input";  units = "lbm/sec";
    description = "Combustor fuel flow error";
  }
  real WfuelLast {
    value = 0.0;  IOstatus = "input";  units = "lbm/sec";
    description = "Previous combustor fuel flow - for loop only";
  }
  real WfuelNew {
    value = 0.0;  IOstatus = "input";  units = "lbm/sec";
    description = "Next combustor fuel flow - for loop only";
  }
  int countFuel {
    value = 0;  IOstatus = "output";
    description = "Fuel loop counter";
  }
  int countFuelMax {
    value = 50;  IOstatus = "input";
    description = "Fuel loop maximum counter";
  }
  int countRayleigh {
    value = 0;  IOstatus = "output";
    description = "Rayleigh loop counter";
  }
  int countRayleighMax {
    value = 25;  IOstatus = "input";
    description = "Rayleigh loop maximum counter";
  }
  int flagRayleighLossTooMuch {
    value = 0;  IOstatus = "output";
    description = "If true, Rayleigh loop results in too much loss";
  }
  int flagRayleighChoked {
    value = 0;  IOstatus = "output";
    description = "If true, Rayleigh loop results in supersonic flow";
  }
  real Pt_comb_inlet {
  value = 0.0;  IOstatus = "output";  units = "psia";
  description = "Pressure entering combustion section";
}
real ER {
  value = 0.862;  IOstatus = "input";  units = "none";
  description = "Equivalence ratio at design";
}
real stoich_FAR {
  value = 0.293;  IOstatus = "input";  units = "none";
  description = "Stoichiometric fuel-to-air ratio";
}
real LHV {
  value = 18400.0;  IOstatus = "input";  units = "Btu/lbm";
  description = "Lower heating value of fuel";
}
real Q_heat {
  value = 0.0;  IOstatus = "output";  units = "Btu/sec";
  description = "Heat release";
}
string result {
  value = "";  IOstatus = "output";
  description = "Interpolation result string";
}
int eq_pos {
  value = 0;  IOstatus = "output";
  description = "Position of equals sign in result string";
}
string Pt_str {
  value = "";  IOstatus = "output";
  description = "Pressure string from result";
}
string Tt_str {
  value = "";  IOstatus = "output";
  description = "Temperature string from result";
}
real Pt_out {
  value = 0.0;  IOstatus = "output";  units = "psia";
  description = "Output pressure from table";
}
real Tt_out {
  value = 0.0;  IOstatus = "output";  units = "R";
  description = "Output temperature from table";
}
real h_out {
  value = 0.0;  IOstatus = "output";  units = "Btu/lbm";
  description = "Output enthalpy";
}
int temp_eq_pos {
  value = 0; IOstatus = "output";
  description = "Temporary equals position";
}
string temp_Pt_str {
  value = ""; IOstatus = "output";
  description = "Temporary Pt string";
}
string temp_Tt_str {
  value = ""; IOstatus = "output";
  description = "Temporary Tt string";
}
real temp_Pt_val {
  value = 0.0; IOstatus = "output"; units = "psia";
  description = "Temporary Pt value";
}
real temp_Tt_val {
  value = 0.0; IOstatus = "output"; units = "R";
  description = "Temporary Tt value";
}
real[] W_grid {
  description = "W grid values from CSV";
}
real[] Pt_grid {
  description = "Pt grid values from CSV";
}
real[] Tt_grid {
  description = "Tt grid values from CSV";
}
string[] RDE_data {
  description = "RDE performance data - stored as 1D array";
}
int nW_size {
  value = 0; IOstatus = "output";
  description = "Number of W grid points";
}
int nPt_size {
  value = 0; IOstatus = "output";
  description = "Number of Pt grid points";
}
int nTt_size {
  value = 0; IOstatus = "output";
  description = "Number of Tt grid points";
}

// Interpolation bounds
real W_lower_bound {
  value = 0.0; IOstatus = "output"; units = "lbm/sec";
  description = "Lower W bound";
}
real W_upper_bound {
  value = 0.0; IOstatus = "output"; units = "lbm/sec";
  description = "Upper W bound";
}
real Pt_lower_bound {
  value = 0.0; IOstatus = "output"; units = "psia";
  description = "Lower Pt bound";
}
real Pt_upper_bound {
  value = 0.0; IOstatus = "output"; units = "psia";
  description = "Upper Pt bound";
}
real Tt_lower_bound {
  value = 0.0; IOstatus = "output"; units = "R";
  description = "Lower Tt bound";
}
real Tt_upper_bound {
  value = 0.0; IOstatus = "output"; units = "R";
  description = "Upper Tt bound";
}
string V000_val { value = ""; IOstatus = "output"; description = "Vertex 000"; }
string V100_val { value = ""; IOstatus = "output"; description = "Vertex 100"; }
string V010_val { value = ""; IOstatus = "output"; description = "Vertex 010"; }
string V110_val { value = ""; IOstatus = "output"; description = "Vertex 110"; }
string V001_val { value = ""; IOstatus = "output"; description = "Vertex 001"; }
string V101_val { value = ""; IOstatus = "output"; description = "Vertex 101"; }
string V011_val { value = ""; IOstatus = "output"; description = "Vertex 011"; }
string V111_val { value = ""; IOstatus = "output"; description = "Vertex 111"; }

int csv_loaded {
  value = 0; IOstatus = "output";
  description = "Flag indicating CSV has been loaded";
}

// Temporary variables for parsing


// Variables for trilinear interpolation
real Pt000 { value = 0.0; IOstatus = "output"; units = "psia"; description = "Vertex 000 Pt"; }
real Tt000 { value = 0.0; IOstatus = "output"; units = "R"; description = "Vertex 000 Tt"; }
real Pt100 { value = 0.0; IOstatus = "output"; units = "psia"; description = "Vertex 100 Pt"; }
real Tt100 { value = 0.0; IOstatus = "output"; units = "R"; description = "Vertex 100 Tt"; }
real Pt010 { value = 0.0; IOstatus = "output"; units = "psia"; description = "Vertex 010 Pt"; }
real Tt010 { value = 0.0; IOstatus = "output"; units = "R"; description = "Vertex 010 Tt"; }
real Pt110 { value = 0.0; IOstatus = "output"; units = "psia"; description = "Vertex 110 Pt"; }
real Tt110 { value = 0.0; IOstatus = "output"; units = "R"; description = "Vertex 110 Tt"; }
real Pt001 { value = 0.0; IOstatus = "output"; units = "psia"; description = "Vertex 001 Pt"; }
real Tt001 { value = 0.0; IOstatus = "output"; units = "R"; description = "Vertex 001 Tt"; }
real Pt101 { value = 0.0; IOstatus = "output"; units = "psia"; description = "Vertex 101 Pt"; }
real Tt101 { value = 0.0; IOstatus = "output"; units = "R"; description = "Vertex 101 Tt"; }
real Pt011 { value = 0.0; IOstatus = "output"; units = "psia"; description = "Vertex 011 Pt"; }
real Tt011 { value = 0.0; IOstatus = "output"; units = "R"; description = "Vertex 011 Tt"; }
real Pt111 { value = 0.0; IOstatus = "output"; units = "psia"; description = "Vertex 111 Pt"; }
real Tt111 { value = 0.0; IOstatus = "output"; units = "R"; description = "Vertex 111 Tt"; }

real w_d { value = 0.0; IOstatus = "output"; units = "none"; description = "W interpolation weight"; }
real p_d { value = 0.0; IOstatus = "output"; units = "none"; description = "Pt interpolation weight"; }
real t_d { value = 0.0; IOstatus = "output"; units = "none"; description = "Tt interpolation weight"; }
real Pt_interp { value = 0.0; IOstatus = "output"; units = "psia"; description = "Interpolated Pt"; }
real Tt_interp { value = 0.0; IOstatus = "output"; units = "R"; description = "Interpolated Tt"; }

  //------------------------------------------------------------
  //   ******* OPTION VARIABLE SETUP *******
  //------------------------------------------------------------

  Option switchAud {
    allowedValues = { "BASE", "AUDIT" }
    description = "Determines if the audit factors are used";
    IOstatus = "input";
    trigger=TRUE;
    rewritableValues = FALSE;  // Enables converter optimization.
  }

  Option switchBurn {
    allowedValues = { "FAR", "FUEL", "WFUEL", "TEMPERATURE" };
    description = "Switch determines if burner is running to fuel flow, FAR, or T4.  Setting option to FUEL will burn using the burner value as an input.  Setting the option to WFUEL will burn using the value coming in from the fuel station.";
    trigger=TRUE;
    rewritableValues = FALSE;
  }

  Option switchDes {
    allowedValues = { "DESIGN", "OFFDESIGN" };
    description = "Design switch";
    trigger=FALSE;
    rewritableValues = FALSE;
  }
  // input kept in for backward compatible (remove later)
  Option switchHotLoss {
    allowedValues = { "INPUT", "CALCULATE","input" };
    description = "Switch determines if the hot pressure loss is input or iterated on";
    trigger=TRUE;
    rewritableValues = FALSE;
  }
	
  //------------------------------------------------------------
  // ****** SETUP PORTS, FLOW STATIONS, SOCKETS, TABLES ********
  //------------------------------------------------------------
  
  // FLUID PORTS
  FluidInputPort Fl_I {
    description = "Incoming flow";
  }
  
  FluidOutputPort Fl_O {
    description = "Exiting flow";
  }
  
  // FUEL PORTS
  
  FuelInputPort Fu_I {
    description = "Incoming fuel flow";
  }
  FuelOutputPort Fu_O {
  description = "Exiting fuel flow";
}
  
  // BLEED PORTS
  
  // THERMAL PORTS
  
  // MECHANICAL PORTS
  
  // FLOW STATIONS
  
  FlowStation Fl_Icomb {
	    description = "Inlet station to combustion section of burner
 (after the initial pressure loss is applied)";
  }
  
  FlowStation Fl_Ocomb {
    description = "Exit station to combustion section of burner
 (before thermal storage heat transfer is calculated)";
  }
  
  // SOCKETS
  
  Socket S_dPqPf {
    allowedValues = { "dPqP_dmd" };
    description = "Dry duct pressure loss";
 //   socketType = "dPqP";
    socketType = "ADIAB_DPNORM";
  }
  
  Socket S_eff {
    allowedValues = { "effBase" };
    description = "Burner adiabatic efficiency";
    socketType = "BURN_EFFICIENCY";
  }
  
  Socket S_Qhx {
    allowedValues = { "Qhx" };
    description = "Thermal storage socket";
    socketType = "HEATTRANSFER";
  }
  

  // TABLES

  //------------------------------------------------------------
  // ******* INTERNAL SOLVER SETUP *******
  //------------------------------------------------------------
  
  //------------------------------------------------------------
  //  ******  ADD SOLVER INDEPENDENTS & DEPENDENTS  ******
  //------------------------------------------------------------
  
  //------------------------------------------------------------
  // ******* VARIABLE CHANGED METHODOLOGY *******
  //------------------------------------------------------------
  void variableChanged( string name, any oldVal ) {
    
    if( name == "switchBurn" ) {
      if ( switchBurn == "FAR" ) {
	FAR.IOstatus = "input";
	Wfuel.IOstatus = "output";
	TtCombOut.IOstatus = "output";
      }
      else if ( switchBurn == "FUEL" ) {
	FAR.IOstatus = "output";
	Wfuel.IOstatus = "input";
	TtCombOut.IOstatus = "output";
      }
      else if ( switchBurn == "WFUEL" ) {
	FAR.IOstatus = "output";
	Wfuel.IOstatus = "output";
	TtCombOut.IOstatus = "output";
      }
      else if ( switchBurn == "TEMPERATURE" ) {
	FAR.IOstatus = "output";
	Wfuel.IOstatus = "output";
	        TtCombOut.IOstatus = "input";
      }
    }

    else if( name == "switchHotLoss" ) {
      if ( switchHotLoss == "INPUT" ) {
	dPqPRayleigh.IOstatus = "input";
      }
      else if ( switchHotLoss == "input"  ){ switchHotLoss = "INPUT"; }
      else {
	dPqPRayleigh.IOstatus = "output";
      }
    }

    else if( name == "switchAud" ) {
      a_dPqPfAud.IOstatus  = "inactive";
      s_dPqPfAud.IOstatus  = "inactive";
	  
      if( switchAud == "AUDIT" ) {
	a_dPqPfAud.IOstatus  = "input";
	s_dPqPfAud.IOstatus  = "input";
      }
    }
  } // end variableChanged()
  
  
  
  
  
  
  
  //------------------------------------------------------------
  //   ******* ACTUAL RDE CHANGES *******						===========================================================================================================================================================
  //------------------------------------------------------------
  
  
 
 void calculate() {
    
    // Copy inlet flow properties first
    Fl_O.copyFlow("Fl_I");
    Fl_O.W = Fl_I.W;
    
    //------------------------------------------------------------
    // Apply pre-combustor duct pressure loss (if any)
    //------------------------------------------------------------
    Pt_comb_inlet = Fl_I.Pt;  // Remove 'real' keyword
    
    if (abs(dPqP_dmd) > 0.0001) {
        dPqPf = dPqP_dmd * s_dPqPf + a_dPqPf;  // Remove 'real' keyword
        Pt_comb_inlet = Fl_I.Pt * (1.0 - dPqPf);
    }
    
    //------------------------------------------------------------
    // DESIGN vs OFF-DESIGN MODE HANDLING
    //------------------------------------------------------------
    
    if (switchDes == "DESIGN") {
        //====================================================
        // DESIGN MODE
        //====================================================
        
        // Determine fuel flow based on switchBurn mode
        if (switchBurn == "FUEL") {
            FAR = Wfuel / Fl_I.W;
        }
        else if (switchBurn == "FAR") {
            // ER and stoich_FAR are now class variables
            FAR = ER * stoich_FAR;
            Wfuel = FAR * Fl_I.W;
        }
        else if (switchBurn == "WFUEL") {
            Wfuel = Fu_I.W;
            FAR = Wfuel / Fl_I.W;
        }
        
        FARDes = FAR;
        
        // result is now a class variable
        result = interpolate_RDE_table(Fl_I.W, Pt_comb_inlet, Fl_I.Tt);
        
        // Parse result - these are now class variables
        eq_pos = result.find("=");
        Pt_str = result.substr(0, eq_pos);
        Tt_str = result.substr(eq_pos + 1);
        Pt_out = toReal(Pt_str);
        Tt_out = toReal(Tt_str);
        
        Fl_O.Pt = Pt_out;
        
        h_out = Fl_O.getTotal_h(Tt_out, FAR);
        Fl_O.setTotal_hP(h_out, Fl_O.Pt);
        
    } else {
        //====================================================
        // OFF-DESIGN MODE
        //====================================================
        
        if (switchBurn == "FUEL") {
            FAR = Wfuel / Fl_I.W;
        }
        else if (switchBurn == "FAR") {
            Wfuel = FAR * Fl_I.W;
        }
        else if (switchBurn == "WFUEL") {
            Wfuel = Fu_I.W;
            FAR = Wfuel / Fl_I.W;
        }
        
        result = interpolate_RDE_table(Fl_I.W, Pt_comb_inlet, Fl_I.Tt);
        
        eq_pos = result.find("=");
        Pt_str = result.substr(0, eq_pos);
        Tt_str = result.substr(eq_pos + 1);
        Pt_out = toReal(Pt_str);
        Tt_out = toReal(Tt_str);
        
        Fl_O.Pt = Pt_out;
        
        h_out = Fl_O.getTotal_h(Tt_out, FAR);
        Fl_O.setTotal_hP(h_out, Fl_O.Pt);
    }
    
    //------------------------------------------------------------
    // AFTER DESIGN CASING
    //------------------------------------------------------------
    
    Fu_O.W = Wfuel;
    Fl_O.FAR = FAR;
    
    dPqP = (Fl_O.Pt - Fl_I.Pt) / Fl_I.Pt;
    
    eff = effBase * s_eff + a_eff;
    Q_heat = Wfuel * LHV * eff;
}
 
 
 string interpolate_RDE_table(real W, real Pt, real Tt) {
  // Read CSV and find bounds/corner values
  read_RDE_data(W, Pt, Tt);
  
  // Interpolate and get result
  string result = trilinear_interpolate(W, Pt, Tt, 
    W_lower_bound, W_upper_bound, 
    Pt_lower_bound, Pt_upper_bound,
    Tt_lower_bound, Tt_upper_bound, 
    V000_val, V100_val, V010_val, V110_val,
    V001_val, V101_val, V011_val, V111_val);
  
  return result;
}

string trilinear_interpolate(real W, real Pt, real Tt,
                             real W_lower, real W_upper,
                             real Pt_lower, real Pt_upper,
                             real Tt_lower, real Tt_upper,
                             string V000, string V100, string V010, string V110,
                             string V001, string V101, string V011, string V111) {
  
  // Calculate interpolation weights
  w_d = (W - W_lower) / (W_upper - W_lower);
  p_d = (Pt - Pt_lower) / (Pt_upper - Pt_lower);
  t_d = (Tt - Tt_lower) / (Tt_upper - Tt_lower);
  
  // Parse all 8 corner strings into Pt and Tt values
  // V000
  temp_eq_pos = V000.find("=");
  temp_Pt_str = V000.substr(0, temp_eq_pos);
  temp_Tt_str = V000.substr(temp_eq_pos + 1);
  Pt000 = toReal(temp_Pt_str);
  Tt000 = toReal(temp_Tt_str);
  
  // V100
  temp_eq_pos = V100.find("=");
  temp_Pt_str = V100.substr(0, temp_eq_pos);
  temp_Tt_str = V100.substr(temp_eq_pos + 1);
  Pt100 = toReal(temp_Pt_str);
  Tt100 = toReal(temp_Tt_str);
  
  // V010
  temp_eq_pos = V010.find("=");
  temp_Pt_str = V010.substr(0, temp_eq_pos);
  temp_Tt_str = V010.substr(temp_eq_pos + 1);
  Pt010 = toReal(temp_Pt_str);
  Tt010 = toReal(temp_Tt_str);
  
  // V110
  temp_eq_pos = V110.find("=");
  temp_Pt_str = V110.substr(0, temp_eq_pos);
  temp_Tt_str = V110.substr(temp_eq_pos + 1);
  Pt110 = toReal(temp_Pt_str);
  Tt110 = toReal(temp_Tt_str);
  
  // V001
  temp_eq_pos = V001.find("=");
  temp_Pt_str = V001.substr(0, temp_eq_pos);
  temp_Tt_str = V001.substr(temp_eq_pos + 1);
  Pt001 = toReal(temp_Pt_str);
  Tt001 = toReal(temp_Tt_str);
  
  // V101
  temp_eq_pos = V101.find("=");
  temp_Pt_str = V101.substr(0, temp_eq_pos);
  temp_Tt_str = V101.substr(temp_eq_pos + 1);
  Pt101 = toReal(temp_Pt_str);
  Tt101 = toReal(temp_Tt_str);
  
  // V011
  temp_eq_pos = V011.find("=");
  temp_Pt_str = V011.substr(0, temp_eq_pos);
  temp_Tt_str = V011.substr(temp_eq_pos + 1);
  Pt011 = toReal(temp_Pt_str);
  Tt011 = toReal(temp_Tt_str);
  
  // V111
  temp_eq_pos = V111.find("=");
  temp_Pt_str = V111.substr(0, temp_eq_pos);
  temp_Tt_str = V111.substr(temp_eq_pos + 1);
  Pt111 = toReal(temp_Pt_str);
  Tt111 = toReal(temp_Tt_str);
  
  // Interpolate Pt values
  Pt_interp = 
    Pt000 * (1-w_d) * (1-p_d) * (1-t_d) +
    Pt100 * (w_d)   * (1-p_d) * (1-t_d) +
    Pt010 * (1-w_d) * (p_d)   * (1-t_d) +
    Pt110 * (w_d)   * (p_d)   * (1-t_d) +
    Pt001 * (1-w_d) * (1-p_d) * (t_d)   +
    Pt101 * (w_d)   * (1-p_d) * (t_d)   +
    Pt011 * (1-w_d) * (p_d)   * (t_d)   +
    Pt111 * (w_d)   * (p_d)   * (t_d);
  
  // Interpolate Tt values
  Tt_interp = 
    Tt000 * (1-w_d) * (1-p_d) * (1-t_d) +
    Tt100 * (w_d)   * (1-p_d) * (1-t_d) +
    Tt010 * (1-w_d) * (p_d)   * (1-t_d) +
    Tt110 * (w_d)   * (p_d)   * (1-t_d) +
    Tt001 * (1-w_d) * (1-p_d) * (t_d)   +
    Tt101 * (w_d)   * (1-p_d) * (t_d)   +
    Tt011 * (1-w_d) * (p_d)   * (t_d)   +
    Tt111 * (w_d)   * (p_d)   * (t_d);
  
  // Return as concatenated string
  string result_str = toStr(Pt_interp) + "=" + toStr(Tt_interp);
  return result_str;
}

void read_csv(string filename) {
  
  InFileStream csv;
  csv.open(filename);
  
  if (!csv.isOpen()) {
    cerr << "ERROR: Cannot open RDE data file: " << filename << endl;
    return;
  }
  
  real[] W_all;
  real[] Pt_all;
  real[] Tt_all;
  string[] data_all;
  
  string line;
  int count;
  int comma1;
  int comma2;
  int comma3;
  real W_val;
  real Pt_val;
  real Tt_val;
  string data_str;
  int idx;
  int i;
  int j;
  int k;
  int idx_1D;
  
  count = 0;
  
  while (csv.getline(line)) {
    if (line.length() > 0) {
      // Parse: W,Pt,Tt,Pt_out=Tt_out
      comma1 = line.find(",");
      comma2 = line.find(",", comma1 + 1);
      comma3 = line.find(",", comma2 + 1);
      
      W_val = toReal(line.substr(0, comma1));
      Pt_val = toReal(line.substr(comma1 + 1, comma2 - comma1 - 1));
      Tt_val = toReal(line.substr(comma2 + 1, comma3 - comma2 - 1));
      data_str = line.substr(comma3 + 1);
      
      W_all.append(W_val);
      Pt_all.append(Pt_val);
      Tt_all.append(Tt_val);
      data_all.append(data_str);
      count++;
    }
  }
  
  csv.close();
  
  // Extract unique sorted values for each dimension
  W_grid = get_unique_sorted(W_all);
  Pt_grid = get_unique_sorted(Pt_all);
  Tt_grid = get_unique_sorted(Tt_all);
  
  nW_size = W_grid.entries();
  nPt_size = Pt_grid.entries();
  nTt_size = Tt_grid.entries();
  
  // Resize 1D array to hold all data
  RDE_data.resize(nW_size * nPt_size * nTt_size);
  
  // Populate 1D array
  for (idx = 0; idx < count; idx++) {
    // Find indices for this data point
    i = find_index(W_grid, W_all[idx]);
    j = find_index(Pt_grid, Pt_all[idx]);
    k = find_index(Tt_grid, Tt_all[idx]);
    
    // Convert to 1D index
    idx_1D = get_1D_index(i, j, k);
    RDE_data[idx_1D] = data_all[idx];
  }
}

real[] get_unique_sorted(real arr) {
  real[] unique;
  int i;
  int j;
  int found;
  real temp;
  
  for (i = 0; i < arr.entries(); i++) {
    found = 0;
    for (j = 0; j < unique.entries(); j++) {
      if (abs(arr[i] - unique[j]) < 0.0001) {
        found = 1;
        break;
      }
    }
    if (found == 0) {
      unique.append(arr[i]);
    }
  }
  
  // Simple bubble sort
  for (i = 0; i < unique.entries() - 1; i++) {
    for (j = 0; j < unique.entries() - i - 1; j++) {
      if (unique[j] > unique[j+1]) {
        temp = unique[j];
        unique[j] = unique[j+1];
        unique[j+1] = temp;
      }
    }
  }
  
  return unique;
}

int find_index(real grid, real value) {
  int i;
  for (i = 0; i < grid.entries(); i++) {
    if (abs(grid[i] - value) < 0.0001) {
      return i;
    }
  }
  return 0; // Default to first index if not found
}

void read_RDE_data(real W, real Pt, real Tt) {
  
  int i_W_lower;
  int i_W_upper;
  int i_Pt_lower;
  int i_Pt_upper;
  int i_Tt_lower;
  int i_Tt_upper;
  
  // Read CSV file once
  if (csv_loaded == 0) {
    read_csv("RDE_performance_data.csv");
    csv_loaded = 1;
  }
  
  // Find W bounds
  i_W_lower = find_lower_index(W_grid, W);
  i_W_upper = i_W_lower + 1;
  W_lower_bound = W_grid[i_W_lower];
  W_upper_bound = W_grid[i_W_upper];

  // Find Pt bounds
  i_Pt_lower = find_lower_index(Pt_grid, Pt);
  i_Pt_upper = i_Pt_lower + 1;
  Pt_lower_bound = Pt_grid[i_Pt_lower];
  Pt_upper_bound = Pt_grid[i_Pt_upper];
  
  // Find Tt bounds
  i_Tt_lower = find_lower_index(Tt_grid, Tt);
  i_Tt_upper = i_Tt_lower + 1;
  Tt_lower_bound = Tt_grid[i_Tt_lower];
  Tt_upper_bound = Tt_grid[i_Tt_upper];

  // Get vertex values using 1D indexing
  V000_val = RDE_data[get_1D_index(i_W_lower, i_Pt_lower, i_Tt_lower)];
  V100_val = RDE_data[get_1D_index(i_W_upper, i_Pt_lower, i_Tt_lower)];
  V010_val = RDE_data[get_1D_index(i_W_lower, i_Pt_upper, i_Tt_lower)];
  V110_val = RDE_data[get_1D_index(i_W_upper, i_Pt_upper, i_Tt_lower)];
  V001_val = RDE_data[get_1D_index(i_W_lower, i_Pt_lower, i_Tt_upper)];
  V101_val = RDE_data[get_1D_index(i_W_upper, i_Pt_lower, i_Tt_upper)];
  V011_val = RDE_data[get_1D_index(i_W_lower, i_Pt_upper, i_Tt_upper)];
  V111_val = RDE_data[get_1D_index(i_W_upper, i_Pt_upper, i_Tt_upper)];
}

int find_lower_index(real grid, real query_value) {
  int i;
  for (i = 0; i < grid.entries() - 1; i++) {
    if (query_value >= grid[i] && query_value < grid[i+1]) {
      return i;
    }
  }
  
  // Edge case: if query is beyond the table, clamp to last valid index
  return grid.entries() - 2;  // Return second-to-last index
}
int get_1D_index(int i, int j, int k) {
  // Convert 3D array index [i][j][k] to 1D index
  // Formula: index = i * (nPt * nTt) + j * nTt + k
  return i * (nPt_size * nTt_size) + j * nTt_size + k;
}

int verify() {
  // Check that inlet port is linked
  if (!Fl_I.isLinked()) {
    cerr << "ERROR: Burner " << getName() << " inlet port Fl_I is not linked" << endl;
    return FALSE;
  }
  
  // Check that outlet port is linked
  if (!Fl_O.isLinked()) {
    cerr << "ERROR: Burner " << getName() << " outlet port Fl_O is not linked" << endl;
    return FALSE;
  }
  
  // Check that fuel inlet port is linked
  if (!Fu_I.isLinked()) {
    cerr << "ERROR: Burner " << getName() << " fuel inlet port Fu_I is not linked" << endl;
    return FALSE;
  }
  
  // Verify CSV file can be loaded (optional, but good check)
  if (csv_loaded == 0) {
    cout << "INFO: CSV will be loaded on first calculate() call" << endl;
  }
  
  return TRUE;
}

 
 
 // Table output
 // 	PR (Pressure Ratio) or Pt
 // 	Tt_out (Exit Total Temperature)
 // 	eff (Combustion Efficiency) (we can hardcode this)
 //
 //
 //
 //
 //
 

 
 
 //  REQUIRED OUTPUTS CHECK LIST
 // FL_O 
 // 	Fl_O.Pt - Total pressure at exit
 // 	Fl_O.Tt - Total temperature at exit
 // 	Fl_O.W - Air mass flow rate (just copy from Fl_I.W)
 // 	Fl_O.FAR - Fuel-to-air ratio
 // Fu_O
 // 	Fu_O.W - Fuel mass flow rate
 // Performance Variables
 // 	Wfuel - Fuel flow (same as Fu_O.W)
 // 	dPqP - Pressure drop ratio (Î”P/P)
 //
 //
 // Notes
 // use Fl_O.setTotal_hP() so that the following are automatic
 // 	Fl_O.ht - Total enthalpy
 // 	Fl_O.s - Entropy
 // 	Fl_O.Ps - Static pressure
 // 	Fl_O.Ts - Static temperature
 // 	Fl_O.MN - Mach number (if area is set)
 // 	Fl_O.gams - Ratio of specific heats
 // 	Fl_O.V - Velocity
 // 	Fl_O.rhos - Static density
 //
 //
 //		TODO: Does pressure inputed into RDE table include duct losses or not?
 //		TODO: Pressure loss before, after RDE? Or included in RDE table?
 //
 //
 //
 //
 
 
  //------------------------------------------------------------
  //   ******* END RDE CHANGES *******						===============================================================================================================================================================
  //------------------------------------------------------------
 
 
  //------------------------------------------------------------
  // register the appropriate errors at build time
  //------------------------------------------------------------
  void VCinit()
  {
    ESOregCreate( 1023901, 8, "", TRUE, FALSE, TRUE ); // provisional
    ESOregCreate( 1093901, 8, "", TRUE, FALSE, TRUE ); // provisional
  }
  
  }
  
#endif
  
